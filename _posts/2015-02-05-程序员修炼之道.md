---
layout: post
title: 程序员修炼之道
subtitle: 程序员修炼之道
author: wangkun 
date: 2015-02-05 22:10:25 +0800
categories: book 
tag: book 
---

#程序员修炼之道

###注重实效的程序员
- 特征如下：
	> 1. 早起的采纳者/快速的改编者
	> 2. 好奇
	> 3. 批判的思考者
	> 4. 有现实感
	> 5. 多才多艺

	------------------

###Tips
	
		**下文以章节作为划分区间集合Tips**
		
####序

		你不应该局限于任何特定的技术，而是应该拥有足够广博的背景和经验基础，以让你能在特定情况下选择好的解决方案。

1. Care About Your Craft 关心你的技艺
2. Think！About Your Work 思考！你的工作

####一、注重实效的哲学

		注重实效的程序猿能够越出直接的问题去思考，总是设法把问题放在更大的语境中，总是设法注意更大的图景。

3. Provide Options，Don't Make Lame Excuses 提供各种选择，不要找蹩脚的借口
	>承担责任，不要说事情做不到，要说明能够做什么挽回局面。
	
4. Don't Live with Broken Windows 不要容忍破窗户
	>- 不要留着“破窗户”`（低劣的设计、错误的决策、糟糕的代码）`不修。
	>- 至少要用木板把它订起来。
	>- “破窗户”会让团队里的人，觉得反正已经这么烂了，写点烂的也无所谓。
	
5. Be a Catalyst for Change 做变化的催化剂
	>- 设计出你可以合理要求的东西，好好开发它。一旦完成，被人们所见，告诉他们如果增加某些功能会更好，人们自然会增加你想要的功能。
	>- 人们发现参与正在发生的成功更加容易。
6. Remeber the Big Picture 记住大图景
	>- 小心温水煮青蛙，项目的拖延都是一天一天完成的。
	>- 留心大图景`(市场的变化)`。
	>- 要持续不断地观察周围发生的事情，而不是你自己正在做的事情`（项目方向的调整，成员的心态等等）`。
	
7.  Make Quality a Requirements Issue 使质量成为需求问题
	>- 不要许诺不可能兑现的时间标度，更不要为赶上最后期限而削减基本的工程内容。
	>- 你所制作的系统的范围和质量应该作为系统需求的一部分规定下来。
	>- 没有完美的软件，所以才有更新迭代的存在。
8. Invest Regularly in Your Knowledge Portfolio 定期为你的知识资产投资
	>**经营资产**
	
	- 定期投资
	
	- 多元化
	
	- 管理风险`（不要把你所有的技术放在一个篮子里）`
	
	- 低买高卖`（新兴的技术流行之前学习它）`
	
	- 重新评估和平衡`（评估正在学习的技术和已有技术在当前的重要性）`
	
	>**投资目标**
	- 每年至少学习一门新语言
	
	- 每季度阅读一本专业书籍
	
	- 也要阅读非技术书籍
	
	- 上课`MOOC，网易公开课`
	
	- 参加本地用户组织
	
	- 实验不同的开发环境和工具
	
	- 跟上潮流`订阅期刊，CocoaChina，码农周刊等等`
	
	- 上网

	        1.切记持续投入十分重要
	        
	        2.学习的过程将拓展你的思维，使你向着新的可能性和新的做事方式拓展
	
9. Critically Analyze What Your Read and Hear 批判的分析你所读到的和听到的
	>- 确保你资产中的知识的正确性
	>- 不要低估商业主义的力量`(搜索到的答案、书籍可能只是出于商业需要出现在前排)`
	>- 不要就此止步，把找到答案视为对你个人的挑战
	
10. It's Both What You Say and the Way You Say It 你说什么和你怎么说同样重要
	>- 规划你想要说的东西
	>- 只有当你在传达信息时，你才是在交流`（了解你的听众的需要、兴趣、能力，针对不同人做适当的修正）`
	>- 选择恰当的时机和恰当的交流风格，以此适应你的听众
	>- 你的主意很重要，应该以美观的方式传递给你的听众
	>- 获取听众的反馈，汲取他们的智慧
	>- 听他们说，鼓励他们提问，请求他们总结你所表达的东西
	>- 及时的反馈听众
	
####二、注重实效的途径

11. Don't Repeat Yourself 不要重复你自己


		
    >系统中的每一项只是都必须具有单一、无歧义、权威的表示。

       >- 强加的重复`（项目标准所致，文档以及多平台等等）`
       >- 无意的重复`（设计缺陷易致）`
       >- 无耐性的重复`（复制粘贴导致）`
       >- 开发者之间的重复 `（团队开发人员交流不足导致）`
	
12. Make It Easy To Reuse 让复用变得容易
	> 在设计和开发时决议以可复用，容易复用为基准，可极大的减少开发周期
13.  Eliminate Effects Between Unrelated Things 消除无关事物之间的影响`（正交设计）`
	>当任何系统的各组件互相高度依赖时，就不再有具备修正这样的事。
	
	>**提高生产率**
	
    - 改动得以局部化，缩短开发和测试时间
	- 促进复用
	- 正交的组件组合在一起，会提高生产效率
		
	>**降低风险**
	
	- 正交的途径能降低任何开发中固有的风险
	- 有问题的代码区域被隔离开来
	- 系统更健壮
	- 更易测试
	- 与供应商、产品或平台不会紧绑
		
	>在软件开发的整个过程（组建团队、产品设计、工具和库的选用、编码、测试以及文档编写）中都应当运用正交设计，保证各方面的独立性。

14. There Are No Final Decisions 不存在最终决策（可撤销性）
	>- 决策需要尽量保持软和和柔韧，因为你不知道什么时候产品的功能需要改动以适应新的市场
	>- 不仅需要保持代码的灵活性，还需要考虑维持架构、部署以及供应商集成等领域的灵活性
15. Use Tracer Bullets to Find the Target 用曳光弹找到目标
	>- 构建新项目时，由于需求不清、使用不熟悉的开发语言、算法、库等等，使用曳光弹更适合
	>- 曳光弹并不是使用过后，就扔掉的代码，而是不断完善保留它，直至完成最后的需求，它就是产品的一部分
	
    >***理解：***
        
        光弹类似开发的过程迭代开发时，用来证明程序逻辑正确、有效，可即时反馈给客户且具备展示效果的代码。完善一个功能模块，便为曳光弹添加代码，验证且使用功能模块。例如，服务器开发时，逻辑完成后，书写的可被别人调用的借口，可属于曳光弹。整体开发时，前端可展示的界面，属于曳光弹。功能逻辑完成很重要，但是可展示的内容也很重要，这是向客户证明项目在走的要素之一。


       >***优点:***

       >- 用户能够及早的看到能工作的东西
       >- 开发者构建了一个他们能在其中工作的机构
       >- 你有了一个集成平台
       >- 你有了可用于演示的东西
       >- 你将更能感觉到工作的进展 

16. Prototype to Learn 为了学习而制作原型


	    构建原型时，可忽略正确性、完整性、健壮性和风格。
	    适当的使用原型，可以帮助你在开发周期的早期确定和改正潜在的问题点——此时改正错误既便宜、又容易。
	

	>**应当制作原型的事物**
		
	>- 架构
	>- 已有系统的新功能
	>- 外部数据的结构或内容
	>- 第三方工具或组件
	>- 性能问题
	>- 用户界面设计
	
	
17. Program Close to the Problem domain 靠近问题领域编程（书写能生成代码的代码，编译器、转译器）
	>将问题用计算机的思路转换为伪代码
18. Estimate to Avoid Surprises 估算，以避免发生意外
	>所有的估算都以问题的模型为基础
	>把握问题域的范围以及估算值的精确度
	>建立模型，分解模型，构造参数，计算值
19. Iterate the Schedule with the Code 通过代码对进度表进行迭代
	>积累经验，趁早完善，减少迭代次数
	
####三、基本工具

		工具放大你的才干。

20. Keep Knowledge in Plain Text 用纯文本保存知识
>***优点***

    >- 方便阅读，毕竟脑容量有限
	>- 保证不过时（人能够阅读的数据，通常比创建它的人活得长久）
	>- 杠杆作用（适应性强，源码管理、编译器环境都能在纯文本上操作）
	>- 易于测试
	
    >***缺点***

    >- 所需空间大
    >- 处理更加繁琐
    >- 保密性差

21. Use the Power of Command Shells 利用命令shell的力量
	>`熟悉shell能极大的增强你的生产效率`
22. Use a Single Editor Well 用好一种编辑器 
	> 编辑器具有可配置、可拓展、可编程的特性，可打造个人习惯的编辑习惯（可实现几乎所有IDE具备的功能，只是需要你去配置）

23. Always Use Source Code Control 总是使用源码控制
	> 源码控制最基本的是实现了代码备份，其次是更好查处Bug所在（昨天的代码没有问题，今天出了，那么只需要查看今天修改的代码就可以），并且现在的源码控制系统，具备了很多很强大的功能，例如撤销等等。
24. Fix the Problem，Not the Blame 要修正问题，而不是发出指责
	> 调试就是解决问题，要据此发起进攻
25. Don't Panic 不要恐慌
	> - 去除"不可能"思想，寻找为什么
	> - 要总是设法找出问题的根源，而不只是问题的特定表现
	> - 让BUG再现，让调试信息可视化，跟踪调试点。
	> - 用橡皮鸭法，理顺思路
	> - `先怀疑自己再怀疑别人`
	
26. "Select" Isn't Broken “Selecet”没有问题
	>如果你看到马蹄印，要想到马，而不是斑马
27. Don’t Assume - Prove It 不要假定，要证明
	>- `你必须意识到假设不一定是对的，必须去证明它，才能保证正确性`
	>- 确保无论发生什么，你都知道它是否会再次发生

28. Learn a Text Manipulation Language 学习一种文本操纵语言
	> 文本操纵语言具备强大的功能，如果你熟悉它的话Python、Perl等等
29. Write Code That Writes Code 编写能编写代码的代码（代码生成器）
	>主动代码生成器，被动代码生成器(不懂如何写)

####四、注重实效的偏执



30. You Can't Write Perfect Software 你不可能写出完美的软件
	> 针对自己的错误进行防卫性编码
	
31. Design With Conteacts 按合约设计
	>- 合约既规定你的权利与责任，也规定对方的权利与责任
	>- 用文档记载程序需要做的事，并进行校验是DBC的核心
	>- `函数设计准则：对在开始之前接受的东西要严格，而允诺返回的东西要尽可能的少`
	>- 继承和多态是面向对象语言的基石，是合约可以真正闪耀的领域
	>- DBC最大的好处是它迫使需求与保证的问题走到前台来

32. Crash Early 早崩溃（死程序）

	>- 所有的错误都能为你提供信息
	>- `尽早检测问题的好处之一是你可以更早崩溃`
	>- 死程序带来的危害通常比有疾患的程序要小得多
33. If It Can't Happen，Use Assertions to Ensure That It Won't  如果它不可能发生，就确保它不会发生（断言编程）
	>- 绝不要把必须执行的代码放入assert中
	>- `不要用断言代替真正的错误处理——断言检测的是决不应该发生的事`
	>- 你的第一条防线是检查任何可能的错误，第二条防线是使用断言设法检测你疏漏的错误
	>- 即便是在性能影响很大的情况下，也只关闭那么有很大影响的断言

34. Use Exceptions for Exceptional Problems 将异常用于异常的问题
	>- 如果文件应该在那里，那么引发异常就有正当理由；如果你不清楚文件是否应该存在，那么就只能是错误返回

35. Finsh What You Start 要有始有终（配平资源）
	>- `资源使用应遵循一种可预测模式：分配、使用、解除分配`
	>- 嵌套的分配
		1. 以与资源分配的次序相反的次序解除资源的分配
		2. 在代码的不同地方分配同一组资源时，总是以相同的次序分配它们
		3. 无论是谁分配的资源，它都应该负责解除该资源的分配
	>- 无法配平资源时
		1. 顶层结构还负责释放它包含的任何子结构
		2. 只是解除顶层结构的分配。它指向的任何结构都会被遗弃
		3. 如果顶层结构含有任何子结构，它就拒绝解除自身的分配。


####五、弯曲，或折断

		生活不会停步不前，我们必须尽一切努力编写尽可能宽松——灵活——的代码。

36. Minimize Coupling Between Modules 使模块之间的耦合减至最少
	>- 应当直接要求提供你所需的东西，而不是间接获取（提升了耦合度）
	>- 对象间直接的横贯关系有可能很快就带来依赖关系的组合爆炸
	>- 德墨忒尔法则
		1. 只得调用它自身的方法
		2. 传入该方法的任何参数的方法
		3. 它创建的任何对象的方法
		4. 任何直接持有的组件对象的方法
	>- 但并不总是需要解耦，也应平衡你的应用的方方面面，选择加耦或者解耦。

37. Configure，Don't Integrate 不要集成，要配置
	>- “把细节赶出去”，让代码高度灵活
	>- 用元数据描述应用的配置选项：调谐参数、用户偏好、安装目录等等
38. Put Abstractions in Code，Details in Metadata 将抽象放进代码，细节放进元数据
>- 好处：

	    1. 迫使你解除你的设计的耦合。
		2. 迫使你通过推迟细节处理，创建更健壮、更抽象的设计——完全推迟叨程序之外
		3. 无需重新编译应用，你就可以对其进行定制；可利用这一特性轻松绕开运行的产品系统的重大Bug
		4. 与通用的编程语言的情况相比，可以通过一种大为接近问题领域的方式表示元数据
		5. 你甚至可以用相同的应用引擎——不同的元数据——实现若干不同的项目！
>- 理想的元数据加载时期位于运行时***
>- 没有元数据，你的代码就不能获得它具有的适应性和灵活性

39. Analyze Workflow to Improve concurrency 分析工作流，以改善并发性
	>- 分析工作流中可同时进行的并发任务，以及任务的次序关系，设计更好的系统
	>- 使用动作图，通过找出本来可以、但却没有并行执行的动作，使并行度最大化

40. Design Using Services 用服务进行设计
41. Always Design for Concurrency 总是为并发进行设计
>- 并发迫使你更仔细的对事情进行思考
>- `对并发和时序的依赖进行思考还能够引导你设计更整洁的接口`

42. Separate Views from Models 使视图与模型分离
>- 模块或类的一个好定义是，它具有单一的、定义良好的责任
>- `通过发布与订阅可完成视图和模型的交互（观察者模式）`

43. Use Blackboards to Coordinate Workflow 用黑板协调工作流（通知中心）
>- 低耦合、多方面信息共享、自由度高、数据无限制
>- 完全解除了耦合，减少了必须编写代码的数量
>- 黑板接口单一，但通用

####六、当你编码时

		编码不是机械工作。在编码过程中，我们无时无刻不在做决策，注重实效的程序猿用以对这些决策仔细的思考和判断，编写高质量的代码。

44. Don't Program by Coincidence 不要靠巧合编程

	>- 总是意识到你在做什么
	>- 不要盲目的编程
	>- 按照计划行事
	>- 依靠可靠的事物（不要依靠巧合和假定）
	>- 为你的假定建立文档
	>- 不要只是测试你的代码，还要测试你的假定
	>- 为你的工作划分优先级
	>- 不要做历史的奴隶（代码当换则换）

45. Estimate the Order of Your Algorithms 估算你的算法的阶
	>- 时间复杂度，空间复杂度，涉及到算法优化
46. Test Your Estimates 测试你的估算
47. Refactor Early，Refactor  Often 早重构，常重构
	>**重构的时机**
	
	>- 重复
	>- 非正交设计
	>- 过时的只是
	>- 性能问题
		
	>**重构的方法**
	
	>- 不要试图在重构的同时增加功能
	>- 确保重构前，拥有良好的测试，改动后能及时找出问题
	>- 采取短小、深思熟虑的步骤：把某个字段从一个类移往另一个，把两个类似的方法融合进超类中。
		
48. Design to Test 为测试而设计
	>- 书写单元测试，考虑如何测试方便，进而改造代码
	>- 针对合约进行测试
	
49. Test Your Software，Or Your Users Will 测试你的软件，否则你的用户就得测试
	>- 编写单元测试，使用测试装备，构建测试窗口（测试信息生成文件，分析），所有内容均需测试

50. Don't Use Wizard Code You Don‘t Understand 不要使用你不理解的想到代码
	>- 智能化安装过程，导致的是对整个系统与软件交互工程的不理解，甚至有更重要的对软件所使用的系统功能的不知所措。

####七、在项目开始之前

		启动太快可能是一个问题，但等的太久可能会更糟
		完美，不是在没有什么需要增加、而是在没有什么需要去掉时达到

51. Don't Gather Requirements - Dig for Them 不要搜集需求——挖掘它们
	>- 需求很少存在于表面上。通常他们深深的埋藏在层层假定、误解和政治手段的下面。
	
52. Work with a User to Think Like a User 与用户一同工作，以像用户一样思考
	>- `找出用户为何要做特定事情的原因、而不只是他们目前做这件事情的方式，这很重要！！！`
	
53. Abstractions Live Longer than Details 抽象比细节活得更长久
	>-  建立需求文档时，应保持抽象。
	>- 在涉及需求的地方，最简单的、能够准确地反映商业需要的陈述是最好的。
	>- `需求不是架构。需求不是设计，也不是用户界面。需求是需要。`

		注意需求蔓延问题，最好能够准确、完整地了解需求增长是怎样以及何时发生的

54. Use a Project Glossary 使用项目词汇表
	>- 便于交流，理应建立项目词汇表，以免在交流中同一个事物，因为使用了不同名词而造成分歧
	
		由于需求的变动性以及流动性，应尽量形成web访问，而不是纸质文档。

55. Don't Think Outside the Box - Find the Box 不要在盒子外面思考——要找到盒子
	>- 确定真正的`（而不是想当然的）`约束，并在其中找出解决方法
	>- 有些约束是绝对的；有些约束是先入之见
	>- 确定你的自由度（问题出现后，你能修改的部分）
	>- 你必须挑战任何先入之见，并评估它们是否是真实的、必须遵守的约束
	>- 问题不在于你是在盒子里面思考，还是在外面是靠，而在于找到盒子——确定真正的约束
		
		在面对棘手的问题时，列出所有在你面前的可能的途径。不要排除任何东西，不管它听起来多么无用和愚蠢。
		**自问：**
		1. 有更容易的方法吗？
		2. 你是在设法解决真正的问题，还是被外围的技术问题转移了注意力？
		3. 这件事情为什么是一个问题？
		4. 是什么使它如此难以解决？
		5. 它必须以这种方式完成吗？
		6. 它真的必须完成吗？

56. Listen to Nagging Doubts - Start When You're Ready 倾听反复出现的疑虑——等你准备好再开始
	>- 在有疑虑时，采用构建原型的方式来进行验证，但需谨记一开始你需要的只是原型

57. Some Things Are Better Done than Described 对有些事情“做”胜于“描述”
	>- 编写规范是一项重要的职责，它是与用户的约定，它是未来代码维护和增强的程序猿的记录
	>- 规范不可能完整描述系统或需求的每一处细节和细微差别，因语言自身的表达能力存在问题
	>- 你应该倾向于把需求搜集、设计、以及实现视为同一个过程——交付高质量的系统——的不同方面
	>- 规范不能具有“紧身衣效应”，不给编码者留下任何解释余地的设计剥夺了他们发挥技巧和艺术才能的权利

58. Don‘t Be a Slave to Formal Methods 不要作形式方法的奴隶
	>- 形式技术和方法应当和你的开发实践和能力的语境中
	>- 注重实效的程序猿批判的看待方法学，并从各种方法中提取精华，融合成每个月都在变得更好的一套工作习惯
	>- 你应该不断奴隶提炼和改善你的开发过程
	>- 不要向方法的虚假权威屈服

59. Expensive Tools Do Not Produce Better Designs 昂贵的工具不一定能制作出更好的设计
	
####八、注重实效的项目

		前述的种种方法对个人有效，对团体同样有效

60. Organize Around Functionality，Not Job Functions 围绕功能、而不是工作职务进行组织`(注重实效的团队)`
	>- 以功能划分团队——在功能需求变化的同时不至于影响其它团队的开发；`能极大地减少各个开发者的工作之间的相互影响、缩短时间标度、提高质量、并减少缺陷的数目`
	
61. Don’t Use Manual Procdures 不要使用手工流程（`无处不在的自动化`）
	>- 编写脚本，让一些繁琐的流程变得简洁高效——编译工作、测试工作、生成代码等等
	
			让计算机去做重复、庸常的事情——它会做得比我们更好。我们有更重要、更困难的事情要做	
	

62. Test Early. Test Often. Test Automatically. 早测试，常测试，自动测试
	>- 测试必须无情，用最恨最极端的方法去测试你的代码

		测试的三个主要方面：测试什么、怎样测试以及何时测试（频繁测试）

63. Coding Ain‘t Done ’Til All the Tests Run‘ 要到通过全部测试，编码才算完成（`测试什么`）
	>- 单元测试
	>- 集成测试
	>- 验证和校验（`界面满足系统的功能需求吗？`）
	>- 资源耗尽、错误以及恢复(`内存空间、磁盘空间、CPU带宽、挂钟时间、磁盘带宽、视频分辨率`)
	>- 性能测试（`每秒事务数、连接数`）
	>- 可用性测试（`对用户而言是否顺手`）

64. Use Saboteurs to Test Your Testing 通过“蓄意破坏”测试你的测试（`怎样测试`）
	>- 回归测试——把当前测试的输出与先前的或已知的值进行对比，确保对Bug的修正没有破坏昨天的代码（`所有测试都应以回归测试运行`）
	>- 测试数据（`运行测试时所需的数据`）
	>- 演练GUI系统
	>- 对测试进行测试
	>- 彻底测试
65. Test state Coverage，Not Code Coverage 测试状态覆盖，而不是代码覆盖
66. Find Bugs One 一个bug只抓一次
	>- 一旦测试人员找到了某个bug，这应该是测试人员最后一次发现这个bug
67. Treat English as Just Another Programming Language 把英语当做又一种编程语言
	>- 注重实效的程序员会把文档当作整个开发过程的完整组成部分加以接受
68. Build Documentation In，Don’t Bolt It On 把文档建在里面，不要栓在外面
	
		代码中的注释应该为何要做某事、它的目的和目标。
		变量的命名应当具体、有意义。
	
69. Gently Exceed Your Users'Expectations 温和地超出用户的期望
	>- 和客户交流，主动控制用户对他们能从系统中得到什么应该抱有的希望
	>- 设法让你的用户惊讶，而不是惊吓，一些简单易添加的特性：
		>1. 气球式帮助或工具提示帮助
		>2. 快捷键
		>3. 作为用户手册的补充材料的快速参考指南
		>4. 彩色化
		>5. 日志文件分析器
		>6. 自动化安装
		>7. 用于检查系统完整性的工具
		>8. 运行系统的多个版本、以进行培训的能力
		>9. 为他们的机构定制的splash屏幕（交互式软件显示的初始画面——译注）

70. Sign Your Work 在你的作品上签名
	>- 担起自己的责任，获得属于自己的名誉
	